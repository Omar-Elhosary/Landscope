
/* eslint-disable no-unused-vars */
import { useRef, useEffect, useState } from "react";
import mapboxgl from "mapbox-gl";
import "mapbox-gl/dist/mapbox-gl.css";
import MapboxGeocoder from "@mapbox/mapbox-gl-geocoder";
import "@mapbox/mapbox-gl-geocoder/dist/mapbox-gl-geocoder.css";
import { updateZoom, updateCoords, updateCenter } from "../store/MapSlice";
import { useDispatch, useSelector } from "react-redux";
import { feature } from "@turf/turf";

function getSquareCorners(centerLat, centerLon) {
  const latOffset = 45 / 111320; // 1 degree latitude ~ 111 km
  const lonOffset = 45 / (111320 * Math.cos(centerLat)); // 1 degree longitude varies

  return [
    [centerLon - lonOffset, centerLat - latOffset],
    [centerLon + lonOffset, centerLat - latOffset],
    [centerLon + lonOffset, centerLat + latOffset],
    [centerLon - lonOffset, centerLat + latOffset],
    [centerLon - lonOffset, centerLat - latOffset],
  ];
}

function drawGrid(coords) {
  // const [userLat, userLon] = coords;
  // const a = 15 / (111320 * Math.cos(userLat));
  // const b = 45 / 111320;
  // const c = 45 / (111320 * Math.cos(userLat));
  // const d = 15 / 111320;
  // const coords_1 = [userLon + a, userLat + b];
  // const coords_2 = [userLon + a, userLat - b];
  // const coords_3 = [userLon - a, userLat + b];
  // const coords_4 = [userLon - a, userLat - b];
  // const coords_5 = [userLon + c, userLat + d];
  // const coords_6 = [userLon + c, userLat - d];
  // const coords_7 = [userLon - c, userLat + d];
  // const coords_8 = [userLon - c, userLat - d];
}

const createGrid = ([longitude, latitude]) => {
  const cellSizeMeters = 30; // Each cell is 30 meters x 30 meters
  const metersPerDegreeLat = 111320;
  const metersPerDegreeLon = 111320 * Math.cos((latitude * Math.PI) / 180);

  // Convert 30 meters to degrees
  const cellSizeLat = cellSizeMeters / metersPerDegreeLat;
  const cellSizeLon = cellSizeMeters / metersPerDegreeLon;

  const grid = [];

  // Create 3x3 grid centered on the user's location
  for (let i = -1; i <= 1; i++) {
    for (let j = -1; j <= 1; j++) {
      const cellCoords = [
        [longitude + i * cellSizeLon, latitude + j * cellSizeLat], // Bottom-left corner
        [longitude + (i + 1) * cellSizeLon, latitude + j * cellSizeLat], // Bottom-right corner
        [longitude + (i + 1) * cellSizeLon, latitude + (j + 1) * cellSizeLat], // Top-right corner
        [longitude + i * cellSizeLon, latitude + (j + 1) * cellSizeLat], // Top-left corner
        [longitude + i * cellSizeLon, latitude + j * cellSizeLat], // Closing the polygon
      ];
      grid.push(cellCoords);
    }
  }

  return grid;
};

// eslint-disable-next-line react/prop-types
function MapSection({ isInteractive }) {
  const coords = useSelector((state) => state.map.coords);
  const zoom = useSelector((state) => state.map.zoom);
  const dispatch = useDispatch();
  // Calculate the corners of the square
  // const corners = getSquareCorners(coords[0], coords[1]);
  // console.log(coords);

  const grid = createGrid(coords);
  const mapRef = useRef();
  const mapContainerRef = useRef();
  const markerRef = useRef(null);

  useEffect(() => {
    mapboxgl.accessToken =
      "pk.eyJ1IjoiYXN0cm92ZXgiLCJhIjoiY20xcnIwajVmMDZ1OTJpcjF5YmRwaXl3cyJ9.FTxUYn9WMsDCPyix8mPjFw";

    // Init Map
    mapRef.current = new mapboxgl.Map({
      container: mapContainerRef.current,
      style: "mapbox://styles/mapbox/dark-v11",
      center: coords,
      zoom: zoom,
    });

    mapRef.current.on("load", () => {
      if (mapRef.current.getSource("grid")) {
        mapRef.current.getSource("grid").setData({
          type: "FeatureCollection",
          features: grid.map((grid_coords) => ({
            type: "Feature",
            geometry: {
              type: "Polygon",
              coordinates: [grid_coords],
            },
          })),
        });
      } else {
        mapRef.current.addSource("grid", {
          type: "geojson",
          data: {
            type: "FeatureCollection",
            features: grid.map((grid_coords) => ({
              type: "Feature",
              geometry: {
                type: "Polygon",
                coordinates: [grid_coords],
              },
            })),
          },
        });
      }

      mapRef.current.addLayer({
        id: "grid-layer",
        type: "fill",
        source: "grid",
        layout: {},
        paint: {
          "fill-color": "#088",
          "fill-opacity": 0.3,
        },
      });
    });

    //   // mapRef.current.addSource("square", {
    //   //   type: "geojson",
    //   //   data: {
    //   //     type: "Feature",
    //   //     geometry: {
    //   //       type: "Polygon",
    //   //       coordinates: [corners],
    //   //     },
    //   //   },
    //   // });

    //   // mapRef.current.addLayer({
    //   //   id: "square-layer",
    //   //   type: "fill",
    //   //   source: "square",
    //   //   layout: {},
    //   //   paint: {
    //   //     "fill-color": "rgba(31, 103, 253, 0.40)", // Color and opacity
    //   //     "fill-outline-color": "#1967fd", // Outline color
    //   //   },
    //   // });

    //   // // 4 out 4
    //   // mapRef.current.addSource("route", {
    //   //   type: "geojson",
    //   //   data: {
    //   //     type: "Feature",
    //   //     properties: {},
    //   //     geometry: {
    //   //       type: "LineString",
    //   //       coordinates: [coords_1, coords_2], // Define the two points
    //   //     },
    //   //   },
    //   // });

    //   // mapRef.current.addLayer({
    //   //   id: "route",
    //   //   type: "line",
    //   //   source: "route",
    //   //   layout: {
    //   //     "line-join": "round",
    //   //     "line-cap": "round",
    //   //   },
    //   //   paint: {
    //   //     "line-color": "#c6c9c9", // Line color
    //   //     "line-width": 4, // Line width
    //   //   },
    //   // });

    //   // mapRef.current.addSource("route_2", {
    //   //   type: "geojson",
    //   //   data: {
    //   //     type: "Feature",
    //   //     properties: {},
    //   //     geometry: {
    //   //       type: "LineString",
    //   //       coordinates: [coords_3, coords_4], // Define the two points
    //   //     },
    //   //   },
    //   // });

    //   // mapRef.current.addLayer({
    //   //   id: "route_2",
    //   //   type: "line",
    //   //   source: "route_2",
    //   //   layout: {
    //   //     "line-join": "round",
    //   //     "line-cap": "round",
    //   //   },
    //   //   paint: {
    //   //     "line-color": "#c6c9c9", // Line color
    //   //     "line-width": 4, // Line width
    //   //   },
    //   // });

    //   // mapRef.current.addSource("route_3", {
    //   //   type: "geojson",
    //   //   data: {
    //   //     type: "Feature",
    //   //     properties: {},
    //   //     geometry: {
    //   //       type: "LineString",
    //   //       coordinates: [coords_6, coords_8], // Define the two points
    //   //     },
    //   //   },
    //   // });

    //   // mapRef.current.addLayer({
    //   //   id: "route_3",
    //   //   type: "line",
    //   //   source: "route_3",
    //   //   layout: {
    //   //     "line-join": "round",
    //   //     "line-cap": "round",
    //   //   },
    //   //   paint: {
    //   //     "line-color": "#c6c9c9", // Line color
    //   //     "line-width": 4, // Line width
    //   //   },
    //   // });

    //   // mapRef.current.addSource("route_4", {
    //   //   type: "geojson",
    //   //   data: {
    //   //     type: "Feature",
    //   //     properties: {},
    //   //     geometry: {
    //   //       type: "LineString",
    //   //       coordinates: [coords_7, coords_5], // Define the two points
    //   //     },
    //   //   },
    //   // });

    //   // mapRef.current.addLayer({
    //   //   id: "route_4",
    //   //   type: "line",
    //   //   source: "route_4",
    //   //   layout: {
    //   //     "line-join": "round",
    //   //     "line-cap": "round",
    //   //   },
    //   //   paint: {
    //   //     "line-color": "#c6c9c9", // Line color
    //   //     "line-width": 4, // Line width
    //   //   },
    //   // });
    // });

    if (isInteractive) {
      // Search Box
      const coordinatesGeocoder = (query) => {
        // Match anything which looks like
        // decimal degrees coordinate pair.
        const matches = query.match(
          /^[ ]*(?:Lat: )?(-?\d+\.?\d*)[, ]+(?:Lng: )?(-?\d+\.?\d*)[ ]*$/i
        );
        if (!matches) {
          return null;
        }

        function coordinateFeature(lng, lat) {
          return {
            center: [lng, lat],
            geometry: {
              type: "Point",
              coordinates: [lng, lat],
            },
            place_name: "Lat: " + lat + " Lng: " + lng,
            place_type: ["coordinate"],
            properties: {},
            type: "Feature",
          };
        }

        const coord1 = Number(matches[1]);
        const coord2 = Number(matches[2]);
        const geocodes = [];

        if (coord1 < -90 || coord1 > 90) {
          // must be lng, lat
          geocodes.push(coordinateFeature(coord1, coord2));
        }

        if (coord2 < -90 || coord2 > 90) {
          // must be lat, lng
          geocodes.push(coordinateFeature(coord2, coord1));
        }

        if (geocodes.length === 0) {
          // else could be either lng, lat or lat, lng
          geocodes.push(coordinateFeature(coord1, coord2));
          geocodes.push(coordinateFeature(coord2, coord1));
        }

        return geocodes;
      };

      const geocoder = new MapboxGeocoder({
        accessToken: mapboxgl.accessToken,
        localGeocoder: coordinatesGeocoder,
        zoom: 4,
        placeholder: "Try: -40, 170",
        mapboxgl: mapboxgl,
        reverseGeocode: true,
        marker: false,
      });
      mapRef.current.addControl(geocoder);
      geocoder.on("result", (e) => {
        const coordinates = e.result.geometry.coordinates;

        if (markerRef.current) {
          markerRef.current.setLngLat(coordinates); // Update existing marker position
        } else {
          // Create a new marker if not already created
          markerRef.current = new mapboxgl.Marker()
            .setLngLat(coordinates)
            .addTo(mapRef.current);
        }

        // Fly to the selected location
        mapRef.current.flyTo({
          center: coordinates,
          zoom: 12,
        });
      });

      // Locate Me
      const geolocate = new mapboxgl.GeolocateControl({
        positionOptions: {
          enableHighAccuracy: true,
        },
        trackUserLocation: true,
        showUserLocation: false, // Disable default blue marker
      });
      mapRef.current.addControl(geolocate);
      geolocate.on("geolocate", (e) => {
        const userCoordinates = [e.coords.longitude, e.coords.latitude];

        if (markerRef.current) {
          markerRef.current.setLngLat(userCoordinates); // Update marker position
        } else {
          markerRef.current = new mapboxgl.Marker()
            .setLngLat(userCoordinates)
            .addTo(mapRef.current); // Add a new marker
        }

        mapRef.current.flyTo({
          center: userCoordinates,
          zoom: 12,
        });
      });

      // Update Coords
      mapRef.current.on("move", () => {
        // get the current center coordinates and zoom level from the map
        const mapCenter = mapRef.current.getCenter();
        const mapZoom = mapRef.current.getZoom();

        // update state
        dispatch(updateCenter([mapCenter.lng, mapCenter.lat]));
        dispatch(updateZoom(mapZoom));
      });

      // Set & Update Marker
      mapRef.current.on("click", (e) => {
        const { lng, lat } = e.lngLat;

        // Remove the previous marker if it exists
        if (markerRef.current) {
          markerRef.current.remove();
        }

        // Create and add the new marker
        markerRef.current = new mapboxgl.Marker(
          new mapboxgl.Marker({ draggable: true })
        )
          .setLngLat([lng, lat])
          .addTo(mapRef.current);

        dispatch(updateCoords([lng, lat]));
      });

      // Add Zoom in, out and Nav
      mapRef.current.addControl(new mapboxgl.NavigationControl());
    }

    return () => {
      mapRef.current.remove();
    };
  }, []);

  console.log("mounted");

  return (
    <>
      <div
        id="map-container"
        className="h-full rounded-xl"
        ref={mapContainerRef}
      />
    </>
  );
}

export default MapSection;
